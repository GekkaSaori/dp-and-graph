\documentclass{article}
\usepackage{ctex}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{minted}
\newcommand{\romannum}[1]{\uppercase\expandafter{\romannumeral#1}}
\begin{document}
\section{Classical Problems}
\subsection{矩阵乘法}
明显地，给矩阵乘法加括号的方案数等于卡特兰数。

另外，我们有以下性质：
\begin{enumerate}
    \item{每一次做矩阵乘法的时候，都是将一个序列内连续区间的矩阵相乘，然后再乘上另外一个区间中的矩阵的乘积，最后再将两个矩阵乘起来。}
    \item{第一个区间中的矩阵乘积的行数等于第二个区间中矩阵乘积的列数。}
\end{enumerate}

定义$dp[i,j]$表示把$[i,j]$这个区间中的矩阵全部乘起来所需要花费的最小代价，则最终答案为$dp[1][n]$，在转移时，枚举一个$k$，表示最后一个乘上去的矩阵是$k$，则我们有以下状态转移方程：
\begin{equation*}
    dp[i,j]=\min\{dp[i,k]+dp[k+1,j]+r[i]\times c[j]\times c[k].\}
\end{equation*}
注意转移时不能按照正常的顺序转移，枚举的应该是区间长度，然后再转移。或者可以使用DFS的方式进行转移。
%TODO CODE
以上代码有一个极大的缺陷，会重复搜索很多状态，所以可以使用记忆化搜索的方式进行优化。可以参照第一节记忆化搜索的写法。

可以很容易的发现，在递归的顺序或枚举的拓扑序不是十分明显时，使用DFS加上记忆化搜索可以使代码清晰明了。

时间复杂度$O(n^3)$.
\subsection{最优三角剖分（Uva 1626）}

把一个n个顶点的凸多边形剖分成三角形。每一个三角形有唯一的权值函数$w(i,j,k)$。求最优剖分方法，最大化权值和。n不超过100，假设函数$w$定义如下：
\begin{equation*}
    w(i,j,k)=e\cos C+i\sin S.
\end{equation*}
设有两个向量：
\begin{equation*}
    \begin{aligned}
        \alpha&=(x_2-x_1,y_2-y_1)\\
        \beta&=(x_3-x_1,y_3-y_1)\\
        \frac{1}{2}(\alpha\times\beta)&=\frac{1}{2}|(\alpha_1\beta_1-\alpha_2\beta_1)|
    \end{aligned}
\end{equation*}
$\cdots\cdots（其余内容被留作课后作业）$

dp[i,j]表示以i,j两个顶点构成的三角形的最大权值，则有：
\begin{equation*}
    dp[i,j]=
    \begin{cases}
        0&,i=j,\\
        \min\limits_{i\le k\le j}\{t[i,k]+t[k+1,j]+w(v_{i-1}v_kv_j)\}&,i<j.
    \end{cases}
\end{equation*}
\subsection{括号序列}
令$dp[i,j]$表示区间$[i,j)$范围内最少需要补多少个括号。
\begin{equation*}
    dp[i,j]=
    \begin{cases}
        0&,i=j,\\
        1&,i+1=j,\\
        dp[i+1,j-1]&,of\,(s)\,or\,[s],\\
        dp[i,k]+dp[k,j]&,i\le k<j.
    \end{cases}
\end{equation*}
\subsection{区间染色\romannum{2}}
与括号序列有些类似，不妨参照括号序列的状态转移。令dp[i,j]把区间$[i,j)$全部染色所需要的最小代价，则有：
\begin{equation*}
    dp[i,j]=
    \begin{cases}
        0&,i=j,\\
        1&,i+1=j,\\
        dp[i,k]+dp[k,j]&,\textbf{...TODO...}
    \end{cases}
\end{equation*}
\subsection{传球问题\romannum{2}}

\end{document}
